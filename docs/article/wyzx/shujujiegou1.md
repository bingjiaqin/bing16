<h1 align="center">数据结构-1</h1>

## 绪论

### 计算

研究对象的本质和规律并进行总结归纳相应的方法以实现高效的计算。

计算=信息处理：借助某种工具，遵照一定规则，以明确而机械的形式进行。

算法：特定计算模型下，旨在解决特性问题的指令序列。具有输入、输出、正确性、确定性、可行性、有穷性的要求。

好的程序：正确、健壮、可读、效率。

计算模型

性能测度：正确性、成本（运行时间+存储空间）。

最坏情况、理想模型

图灵机（读写头）、RAM模型

大O记号：常系数可忽略、低次项可忽略。

大omega：下界（最好情况）。

大theta：确界？？？

多项式复杂度、指数复杂度（如两个子集的划分问题是一个典型的NPC问题）

增长速度

### 算法分析

主要任务：正确性（不变性×单调性）+复杂度

复杂度分析的主要方法：

*   迭代：级数求和
*   递归：递归跟踪+递推方程
*   猜测+验证

起泡排序

封底估计

*   1天～10^5 sec
*   1世纪～3\*10^9 sec
*   三生三世～10^10 sec
*   宇宙大爆炸至今～10^21 sec
*   phi^36～2^25

### 动态规划

递归->迭代

fib()迭代解决方法：A.记忆；B.动态规划

LCS最长公共子序列：A.递归（减而治之+分而治之）；B.动态规划

## 向量

抽象数据类型：数据模型+定义在该模型上的一组操作

数据结构：基于某种特定语言，实现ADT的一整套算法

### 接口与实现

初始化、插入、剔除、size、查找、排序等操作

构造与析构、复制等操作

### 可扩充向量

递增式扩容（最坏情况：在初始容量1的满向量中连续插入n=m×I>>2个元素，总体耗时O(n^2)）、加倍式策略（最坏情况：在初始容量1的满向量中连续插入n=2^m>>2个元素，总体耗时O(n)）

平均复杂度（根据出现的概率加权平均，割裂了操作之间的相关性和连贯性）、分摊复杂度（足够多次数后分摊至单次操作，更加忠实地刻画了可能出现的操作序列）

### 无序向量

循秩访问：  
template <typename T>  
T & Vector::operator\[\](Rank r) const { return \_elem\[r\]; }

插入：检查容量+后移+更新

区间删除：移动+检查容量；单元素删除

查找

唯一化：划分为三个部分（当前、前缀、后继），通过当前在前缀中查找，如果出现，则剔除当前。O(n^2)

遍历

### 有序向量

唯一化：有可能被删除的元素会被后继多次地前移

二分查找版本A：O(1.5log(n))，向左和向右比较次数不等而递归深度相同

Fibonacci查找：若设n=fib(k)-1，则取mi=fib(k-1)-1，前、后子向量长度分别为fib(k-1)-1、fib(k-2)-1

二分查找改进版本B：向左或向右只进行一次比较，整体性能更加稳定

二分查找改进版本C：待查找区间宽度至0而非1才结束；转入右侧子向量时，左边界取作mi+1；返回--lo

插值查找：假设线性分布，O(log(log(n)))，除非查找区间宽度极大，或者比较操作成本非常高，因为容易受到小扰动的干扰，须引入乘法除法的运算

起泡排序：O(n^2)

起泡排序改进1：扫描过程中记录是否存在逆序

起泡排序改进2：记录上一次扫描的最后一次交换（对于++lo且交换lo-1和lo，令last=lo），减小hi（hi=last）

归并排序：O(nlog(n))

``` cpp
template <typename T>;
void Vector<T>::mergeSort(Rank lo, Rankhi) {
    if (hi-li<2) return;
    int mi = (lo+hi)>>1;
    mergeSort(lo,mi);
    mergeSort(mi,hi);
    merge(lo,mi,hi);
}

template <typename T>;
void Vector<T>::mergeSort(Rank lo, Rankhi) {
    T* A = _elem + lo;
    int lb = mi - lo; T* B = new T[lb];
    for (Rank i = 0; i < lb; B[i] = A[i++]); // 复制向前子向量B
    int lc = hi - mi; T* C = _elem + mi; // 向后子向量C
    /*
    for (Rank i = 0, j = 0, k = 0; (j < lb || k <lc);){
        if((j<lb)&&(lc<=k||B[j]<=C[k])))A[i++]=B[j++];
        if((k<lc)&&(lb<=j||C[k]<=B[j])))A[i++]=C[j++];
    } // 此循环实现紧凑，但就效率而言不如拆分处理
    */
    // 简化：
    for (Rank i = 0, j = 0, k = 0; j < lb;){
        if((k<lc)&&C[k]<=B[j]))A[i++]=C[j++];
        if(B[j]<=C[k]))A[i++]=B[j++];
    } // 交换循环体内的次序，删除冗余逻辑
    delect [] B;
}
```

## 列表

### 接口与实现

从静态到动态：操作、存储空间的结构（各节点通过指针或引用彼此相联接）

头、首、……、末、尾

### 无序列表

插入和复制、删除与析构、唯一化

### 有序列表

唯一化

查找

选择排序：从交换次数上看，比起泡排序有很大的提高

插入排序

## 栈与队列

### 栈接口与实现

### 栈应用

进制转换

括号匹配

栈混洗

中缀表达式求值：符号栈、数字栈

逆波兰表达式：添加括号、将运算符移到对应右括号右侧、抹去括号。（前一个优先级大于时符号才入栈）

### 队列

一端进，一端出

## 二叉树

### 树

有根树、有序树

路径+环路、连通+无环

树是在无环、连通间达到平衡的图

深度、高度

## 图